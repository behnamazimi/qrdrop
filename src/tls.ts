import { existsSync, writeFileSync } from "fs";
import { generate } from "selfsigned";
import { formatError } from "./utils/error";
import { getNetworkInfo } from "./network";
import { join } from "path";
import { color, success, error, info } from "./output";

/**
 * Certificate expiry information
 */
interface CertificateInfo {
  valid: boolean;
  expiresAt: Date | null;
  daysUntilExpiry: number | null;
  subject: string | null;
  issuer: string | null;
  error?: string;
}

/**
 * Check certificate expiry and validity
 * Uses file modification time to estimate expiry (certificates are valid for 365 days)
 * @param certPath - Path to the certificate file
 * @returns Certificate information including expiry date
 */
function checkCertificateExpiry(certPath: string): CertificateInfo {
  if (!existsSync(certPath)) {
    return {
      valid: false,
      expiresAt: null,
      daysUntilExpiry: null,
      subject: null,
      issuer: null,
      error: "Certificate file not found",
    };
  }

  try {
    // Use file modification time to estimate expiry
    // (certificates generated by us are valid for 365 days)
    const stats = Bun.file(certPath).lastModified;
    const createdAt = new Date(stats);
    const expiresAt = new Date(createdAt.getTime() + 365 * 24 * 60 * 60 * 1000);
    const now = new Date();
    const daysUntilExpiry = Math.floor(
      (expiresAt.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
    );

    return {
      valid: daysUntilExpiry > 0,
      expiresAt,
      daysUntilExpiry,
      subject: "qrdrop",
      issuer: "qrdrop (self-signed)",
    };
  } catch (error) {
    return {
      valid: false,
      expiresAt: null,
      daysUntilExpiry: null,
      subject: null,
      issuer: null,
      error: formatError(error),
    };
  }
}

/**
 * Check if certificate is expiring soon (within specified days)
 * @param certPath - Path to the certificate file
 * @param warningDays - Number of days before expiry to warn (default: 30)
 * @returns Object with expiry status and warning message if applicable
 */
export function isCertificateExpiringSoon(
  certPath: string,
  warningDays: number = 30
): { expiringSoon: boolean; expired: boolean; message?: string } {
  const info = checkCertificateExpiry(certPath);

  if (!info.valid || info.daysUntilExpiry === null) {
    if (info.daysUntilExpiry !== null && info.daysUntilExpiry <= 0) {
      return {
        expiringSoon: true,
        expired: true,
        message: `Certificate has expired (${Math.abs(info.daysUntilExpiry)} days ago)`,
      };
    }
    return {
      expiringSoon: false,
      expired: false,
      message: info.error,
    };
  }

  if (info.daysUntilExpiry <= warningDays) {
    return {
      expiringSoon: true,
      expired: false,
      message: `Certificate expires in ${info.daysUntilExpiry} days (${info.expiresAt?.toLocaleDateString()})`,
    };
  }

  return {
    expiringSoon: false,
    expired: false,
  };
}

/**
 * Generate a self-signed SSL/TLS certificate for HTTPS
 * Uses selfsigned library - no external OpenSSL dependency required
 * @param certPath - Path where the certificate file should be saved
 * @param keyPath - Path where the private key file should be saved
 * @param hostname - Hostname or IP to include in the certificate
 * @returns Promise that resolves when certificate is generated
 * @throws Error if certificate generation fails
 * @note If certificate files already exist, this function does nothing
 */
export async function generateSelfSignedCert(
  certPath: string,
  keyPath: string,
  hostname: string
): Promise<void> {
  if (existsSync(certPath) && existsSync(keyPath)) {
    return; // Certificate already exists
  }

  try {
    const attrs = [
      { name: "commonName", value: hostname },
      { name: "organizationName", value: "qrdrop" },
    ];

    // Calculate notAfterDate (365 days from now)
    const notBeforeDate = new Date();
    const notAfterDate = new Date();
    notAfterDate.setDate(notAfterDate.getDate() + 365);

    const pems = await generate(attrs, {
      keySize: 2048, // Reduced from 4096 for faster generation
      notBeforeDate,
      notAfterDate,
      algorithm: "sha256",
      extensions: [
        {
          name: "subjectAltName",
          altNames: [
            // Add hostname as DNS name if it looks like a domain
            ...(hostname.includes(".") && !hostname.match(/^\d+\.\d+\.\d+\.\d+$/)
              ? [{ type: 2, value: hostname }] // DNS name
              : []),
            // Add as IP if it looks like an IP address
            ...(hostname.match(/^\d+\.\d+\.\d+\.\d+$/)
              ? [{ type: 7, ip: hostname }] // IP address
              : []),
            // Always include localhost
            { type: 2, value: "localhost" },
            { type: 7, ip: "127.0.0.1" },
          ],
        },
      ],
    });

    // Write certificate and key files
    writeFileSync(certPath, pems.cert, "utf-8");
    writeFileSync(keyPath, pems.private, "utf-8");
  } catch (error) {
    throw new Error(`Failed to generate self-signed certificate: ${formatError(error)}`);
  }
}

/**
 * Generate a self-signed certificate with force option (overwrites existing)
 * @param certPath - Path where the certificate file should be saved
 * @param keyPath - Path where the private key file should be saved
 * @param hostname - Hostname or IP to include in the certificate
 * @param force - If true, overwrite existing certificate files
 */
export async function generateSelfSignedCertForce(
  certPath: string,
  keyPath: string,
  hostname: string,
  force: boolean = false
): Promise<void> {
  if (!force && existsSync(certPath) && existsSync(keyPath)) {
    return; // Certificate already exists
  }

  try {
    const attrs = [
      { name: "commonName", value: hostname },
      { name: "organizationName", value: "qrdrop" },
    ];

    // Calculate notAfterDate (365 days from now)
    const notBeforeDate = new Date();
    const notAfterDate = new Date();
    notAfterDate.setDate(notAfterDate.getDate() + 365);

    const pems = await generate(attrs, {
      keySize: 2048,
      notBeforeDate,
      notAfterDate,
      algorithm: "sha256",
      extensions: [
        {
          name: "subjectAltName",
          altNames: [
            // Add hostname as DNS name if it looks like a domain
            ...(hostname.includes(".") && !hostname.match(/^\d+\.\d+\.\d+\.\d+$/)
              ? [{ type: 2, value: hostname }] // DNS name
              : []),
            // Add as IP if it looks like an IP address
            ...(hostname.match(/^\d+\.\d+\.\d+\.\d+$/)
              ? [{ type: 7, ip: hostname }] // IP address
              : []),
            // Always include localhost
            { type: 2, value: "localhost" },
            { type: 7, ip: "127.0.0.1" },
          ],
        },
      ],
    });

    // Write certificate and key files
    writeFileSync(certPath, pems.cert, "utf-8");
    writeFileSync(keyPath, pems.private, "utf-8");
  } catch (error) {
    throw new Error(`Failed to generate self-signed certificate: ${formatError(error)}`);
  }
}

/**
 * Command handler for generating TLS certificates
 * @param hostOverride - Optional IP address or FQDN to use
 * @param interfaceName - Optional network interface name
 * @param certPath - Optional custom certificate file path
 * @param keyPath - Optional custom private key file path
 */
export async function generateCertificateCommand(
  hostOverride?: string,
  interfaceName?: string,
  certPath?: string,
  keyPath?: string
): Promise<void> {
  try {
    // Get network info to detect IP
    const networkInfo = await getNetworkInfo(
      hostOverride,
      undefined, // port not needed
      true, // secure = true to get HTTPS URL format
      interfaceName
    );

    const hostname = hostOverride || networkInfo.ip;

    // Default paths: current directory
    const defaultCertPath = certPath || join(process.cwd(), "qrdrop-cert.pem");
    const defaultKeyPath = keyPath || join(process.cwd(), "qrdrop-key.pem");

    // Check if certificates already exist
    if (existsSync(defaultCertPath) || existsSync(defaultKeyPath)) {
      console.log(error(`Certificate files already exist:`));
      if (existsSync(defaultCertPath)) {
        console.log(`  Certificate: ${defaultCertPath}`);
      }
      if (existsSync(defaultKeyPath)) {
        console.log(`  Private key: ${defaultKeyPath}`);
      }
      console.log(
        `\nTo regenerate, delete the existing files or use --cert and --key to specify different paths.`
      );
      process.exit(1);
    }

    console.log(`${color.cyan("qrdrop")} - Certificate Generation\n`);
    console.log(info(`Generating certificate for: ${hostname}`));
    console.log(info(`Certificate will be saved to: ${defaultCertPath}`));
    console.log(info(`Private key will be saved to: ${defaultKeyPath}\n`));

    // Generate certificate
    await generateSelfSignedCertForce(defaultCertPath, defaultKeyPath, hostname, false);

    console.log(success("Certificate generated successfully!\n"));
    console.log("To use this certificate:");
    console.log(
      `  ${color.cyan(`qrdrop --cert ${defaultCertPath} --key ${defaultKeyPath} --file document.pdf`)}`
    );
    console.log(
      `\nOr if using default paths (qrdrop-cert.pem and qrdrop-key.pem in current directory):`
    );
    console.log(`  ${color.cyan(`qrdrop --secure --file document.pdf`)}`);
    console.log(`\nNote: Browsers will show a security warning for self-signed certificates.`);
    console.log(`This is normal and safe for local network use.`);
  } catch (err) {
    console.error(error(`Failed to generate certificate: ${formatError(err)}`));
    process.exit(1);
  }
}
